var documenterSearchIndex = {"docs":
[{"location":"api/#Contents","page":"API","title":"Contents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#types-and-methods","page":"API","title":"types and methods","text":"","category":"section"},{"location":"api/#GCIdentifier.GCPair","page":"API","title":"GCIdentifier.GCPair","text":"GCPair(smarts,name;group_order = 1)\n\nStruct used to hold a description of a group. Contains the SMARTS string necessary to match the group within a SMILES query, and the assigned name. the group_order parameter is used for groups that follow a Constantinou-Gani approach: the list of GCPair with group_order = 1 will be matched with strict coverage (failing if there is missing atoms to cover) while second order groups and above will not be stringly checked for total coverage. Each order group will be matched independendly.\n\n\n\n\n\n","category":"type"},{"location":"api/#GCIdentifier.get_groups_from_smiles","page":"API","title":"GCIdentifier.get_groups_from_smiles","text":"get_groups_from_smiles(smiles::String,groups;connectivity = false,check = true)\n\nGiven a SMILES string and a group list (groups::Vector{GCPair}), returns a list of groups and their corresponding amount.\n\nIf connectivity is true, then it will additionally return a vector containing the amount of bonds between each pair.\n\nExamples\n\njulia> get_groups_from_smiles(\"CCO\",UNIFACGroups)\n(\"CCO\", [\"CH3\" => 1, \"CH2\" => 1, \"OH(P)\" => 1])\n\njulia> get_groups_from_smiles(\"CCO\",JobackGroups,connectivity = true)\n(\"CCO\", [\"-CH3\" => 1, \"-CH2-\" => 1, \"-OH (alcohol)\" => 1], [(\"-CH3\", \"-CH2-\") => 1, (\"-CH2-\", \"-OH (alcohol)\") => 1])\n\n\n\n\n\n","category":"function"},{"location":"api/#GCIdentifier.get_groups_from_name","page":"API","title":"GCIdentifier.get_groups_from_name","text":"get_groups_from_name(name::String,groups;connectivity = false)\n\nGiven a molecule name and a group list (groups::Vector{GCPair}), returns a list of groups and their corresponding amount.\n\nIf connectivity is true, then it will additionally return a vector containing the amount of bonds between each pair.\n\nNote: Can only be used if the ChemicalIdentifiers package is also installed and loaded (using ChemicalIdentifiers).\n\nExamples\n\njulia> get_groups_from_name(\"ethanol\",UNIFACGroups)\n(\"ethanol\", [\"CH3\" => 1, \"CH2\" => 1, \"OH(P)\" => 1])\n\njulia> get_groups_from_name(\"ethanol\",JobackGroups,connectivity = true)\n(\"ethanol\", [\"-CH3\" => 1, \"-CH2-\" => 1, \"-OH (alcohol)\" => 1], [(\"-CH3\", \"-CH2-\") => 1, (\"-CH2-\", \"-OH (alcohol)\") => 1])\n\n\n\n\n\n","category":"function"},{"location":"api/#GCIdentifier.find_missing_groups_from_smiles","page":"API","title":"GCIdentifier.find_missing_groups_from_smiles","text":"find_missing_groups_from_smiles(smiles::String, groups;max_group_size = nothing, environment=false, reduced=false)\n\nGiven a SMILES string and a group list (groups::Vector{GCPair}), returns a list of potential groups (new_groups::Vector{GCPair}) which could cover those atoms not covered within groups. If no groups vector is provided, it will simply generate all possible groups for the molecule.\n\nA set of heuristics are built into the code when it comes to combining heavy atoms into large groups:\n\nIf a carbon atom is bonded to another carbon atom, unless only one of the carbons is on a ring, they will not be combined into a group.\nAll other combinations of atoms are allowed.\n\nThe logic behind the first heuristic is due to the fact that neighbouring atoms with similar electronegativities won't have a great impact on each other's properties. As such, they are not combined into a group. In the future, this approach could be extended to use HNMR data to determine which atoms can be combined into the same group.\n\nOptional arguments:\n\nmax_group_size::Int: The maximum number of atoms within a group to be generated. If nothing, the maximum size is however many atoms a central atom is bonded to.\nenvironment::Bool: If true, the groups SMARTS will include information about the environment of the group is in. For example, in pentane, if environment is false, there will only be one CH2 group, whereas, if environment is true, there will be two CH2 groups, one bonded to CH3 and one bonded to another CH2.\nreduced::Bool: If true, the groups will be generated such that the minimum number of groups required to represent the molecule, based on max_group_size, will be generated. If false, all possible groups will be generated.\n\nExample\n\njulia> find_missing_groups_from_smiles(\"CC(=O)O\")\n7-element Vector{GCIdentifier.GCPair}:\n GCIdentifier.GCPair(\"[CX4;H3;!R]\", \"CH3\")\n GCIdentifier.GCPair(\"[CX3;H0;!R]\", \"C=\")\n GCIdentifier.GCPair(\"[OX1;H0;!R]\", \"O=\")\n GCIdentifier.GCPair(\"[OX2;H1;!R]\", \"OH\")\n GCIdentifier.GCPair(\"[CX3;H0;!R](=[OX1;H0;!R])\", \"C=O=\")\n GCIdentifier.GCPair(\"[CX3;H0;!R]([OX2;H1;!R])\", \"C=OH\")\n GCIdentifier.GCPair(\"[CX3;H0;!R](=[OX1;H0;!R])([OX2;H1;!R])\", \"C=O=OH\")\n\n\n\n\n\n","category":"function"},{"location":"api/#GCIdentifier.get_grouplist","page":"API","title":"GCIdentifier.get_grouplist","text":"get_grouplist(x)\n\nShould return a Vector{GCPair} containing the available groups for SMILES matching.\n\n\n\n\n\n","category":"function"},{"location":"api/#GCIdentifier.@gcstring_str","page":"API","title":"GCIdentifier.@gcstring_str","text":"@gcstring_str(str)\n\ngiven a string of the form \"Group1:n1;Group2:2\", returns [\"Group1\" => n1,\"Group2\" => n2]\n\n\n\n\n\n","category":"macro"},{"location":"api/#GCIdentifier.group_replace","page":"API","title":"GCIdentifier.group_replace","text":"group_replace(grouplist,keys...)\n\ngiven a group list generated by get_groups_from_smiles, replaces certain groups in grouplist with the values specified in keys.\n\nExamples\n\ngroups1 = get_groups_from_smiles(\"CCO\", UNIFACGroups) #[\"CH3\" => 1, \"CH2\" => 1, \"OH(P)\" => 1]\n#we replace each \"OH(P)\" with 1 \"OH\" group\n#and each \"CH3\" group with 3 \"H\" group and 1 \"C\" group\ngroups2 = group_replace(groups1[2],\"OH(P)\" => (\"OH\" => 1), \"CH3\" => [(\"C\" => 1),(\"H\" => 3)])\n\n\n\n\n\n","category":"function"},{"location":"group_search/#Group-Assignment","page":"Group Assignment","title":"Group Assignment","text":"","category":"section"},{"location":"group_search/","page":"Group Assignment","title":"Group Assignment","text":"The primary function of GCIdentifier is to automatically assign groups to a molecule given a specific group-contribution method. This assumes that the groups in the method being used are extensive enough to cover most molecules that might be of interest.","category":"page"},{"location":"group_search/","page":"Group Assignment","title":"Group Assignment","text":"Let's consider the case where we want to get the groups for ibuprofen from the UNIFAC group-contribution method. The SMILES representation for ibuprofen is CC(Cc1ccc(cc1)C(C(=O)O)C)C. To get the corresponding groups, simply use:","category":"page"},{"location":"group_search/","page":"Group Assignment","title":"Group Assignment","text":"julia> (smiles,groups) = get_groups_from_smiles(\"CC(Cc1ccc(cc1)C(C(=O)O)C)C\", UNIFACGroups)\n(\"CC(Cc1ccc(cc1)C(C(=O)O)C)C\", [\"COOH\" => 1, \"CH3\" => 3, \"CH\" => 1, \"ACH\" => 4, \"ACCH2\" => 1, \"ACCH\" => 1])","category":"page"},{"location":"group_search/","page":"Group Assignment","title":"Group Assignment","text":"where smiles will output the molecular SMILES and groups is a vector of pairs where the first element is the group name and the second is the number of times the group occurs within the molecule. If this function fails, it is usually because, either, the SMILES is unphysical, or the method used doesn't cover all atoms present within a molecule. In the case of the latter, one can still obtain the groups that have been identified by specifying check=false in the optional arguments. For example, SAFT-gamma Mie does not have the functional group for ketones:","category":"page"},{"location":"group_search/","page":"Group Assignment","title":"Group Assignment","text":"julia> (smiles,groups) = get_groups_from_smiles(\"CCC(=O)CC\", SAFTgammaMieGroups; check=false)\n(\"CCC(=O)CC\", [\"CH3\" => 2, \"CH2\" => 2])","category":"page"},{"location":"group_search/","page":"Group Assignment","title":"Group Assignment","text":"To propose new groups that cover the missing atoms, take a look at our find_missing_groups function.","category":"page"},{"location":"group_search/#Connectivity","page":"Group Assignment","title":"Connectivity","text":"","category":"section"},{"location":"group_search/","page":"Group Assignment","title":"Group Assignment","text":"There are certain group-contribution approaches, such as gcPCP-SAFT and s-SAFT-gamma Mie where information about how groups are linked to each other is required. It is possible to obtain information about the connectivity between groups from GCIdentifier by simply specifying connectivity=true within the get_groups_from_smiles function. For example, in the case of acetone:","category":"page"},{"location":"group_search/","page":"Group Assignment","title":"Group Assignment","text":"julia> (smiles,groups,connectivity) = get_groups_from_smiles(\"CC(=O)C\", gcPPCSAFTGroups; connectivity=true)\n(\"CC(=O)C\", [\"C=O\" => 1, \"CH3\" => 2], [(\"C=O\", \"CH3\") => 2])","category":"page"},{"location":"group_search/","page":"Group Assignment","title":"Group Assignment","text":"where connectivity is a vector of pairs where the first element is the groups involved in the link and the second element is the number of times this link occurs.","category":"page"},{"location":"group_search/#Extensions","page":"Group Assignment","title":"Extensions","text":"","category":"section"},{"location":"group_search/","page":"Group Assignment","title":"Group Assignment","text":"Unfortunately, the process of obtaining the SMILES representation of a molecule can be itself a challenge. As such, we have included an extension of GCIdentifier where, if called in conjunction with ChemicalIdentifiers, one can simply specify the molecule name:","category":"page"},{"location":"group_search/","page":"Group Assignment","title":"Group Assignment","text":"julia> using ChemicalIdentifiers\n\njulia> (component,groups) = get_groups_from_name(\"ibuprofen\",UNIFACGroups)\n(\"ibuprofen\", [\"COOH\" => 1, \"CH3\" => 3, \"CH\" => 1, \"ACH\" => 4, \"ACCH2\" => 1, \"ACCH\" => 1])","category":"page"},{"location":"group_search/","page":"Group Assignment","title":"Group Assignment","text":"This should greatly simplify the use of GCIdentifier. These groups can then be used in packages such as Clapeyron to be used to obtain our desired properties, such as the solubility of ibuprofen in water:","category":"page"},{"location":"group_search/","page":"Group Assignment","title":"Group Assignment","text":"julia> using Clapeyron\n\njulia> liquid = UNIFAC([\"water\",(component,groups)])\n\njulia> solid = SolidHfus([\"water\",\"ibuprofen\"])\n\njulia> model = CompositeModel([\"water\",\"ibuprofen\"]; solid=solid, liquid=liquid)\n\njulia> sle_solubility(model,1e5,298.15, [1.,0.]; solute=[\"ibuprofen\"])[2]\n5.547514144547524e-7","category":"page"},{"location":"missing_groups/#Find-Missing-Groups","page":"Finding Missing Groups","title":"Find Missing Groups","text":"","category":"section"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"In some cases, our group contribution method will not have every group needed to cover every atom within a molecule. The example we gave previously was how SAFT-gamma Mie lacked a group for ketones:","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"julia> (smiles,groups) = get_groups_from_smiles(\"CCC(=O)CC\", SAFTgammaMieGroups)\nERROR: Could not find all groups for CCC(=O)CC","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"In this case, it could be possible that GCIdentifier simply hasn't included the missing group within our database or perhaps that group needs to be parameterised. To find out which groups might help fill-in the missing atoms, one can use find_missing_groups_from_smiles:","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"julia> groups = find_missing_groups_from_smiles(\"CCC(=O)CC\", SAFTgammaMieGroups)\n3-element Vector{GCPair}:\n GCPair(\"[CX3;H0;!R]\", \"C=\")\n GCPair(\"[OX1;H0;!R]\", \"O=\")\n GCPair(\"[CX3;H0;!R](=[OX1;H0;!R])\", \"C=O=\")","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"where groups is a vector of GCPairs with proposed names of the groups. As we can see, GCIdentifier has proposed three potential groups, where the last is a combination of the first two. From this list, the users can decide which group might be best to parameterise. However, we also have our own internal heuristics for proposing a minimal group representation of molecules within GCIdentifier which will reduce this list to what we recommend:","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"julia> groups = find_missing_groups_from_smiles(\"CCC(=O)CC\", SAFTgammaMieGroups; reduced=true)\n1-element Vector{GCPair}:\n GCPair(\"[CX3;H0;!R](=[OX1;H0;!R])\", \"C=O=\")","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"In the case of the ketone, we would only really want to parameterise this group.","category":"page"},{"location":"missing_groups/#Automatically-fragment-a-molecule","page":"Finding Missing Groups","title":"Automatically fragment a molecule","text":"","category":"section"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"Let us now consider an extreme case where we are trying to fragment a molecule into groups with no reference group-contribution approach. In the case of our ketone, the code will fragment the molecule into atomic groups, along with combinations of those atomic groups:","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"julia> groups = find_missing_groups_from_smiles(\"CCCC(=O)CCC\")\n5-element Vector{GCPair}:\n GCPair(\"[CX4;H3;!R]\", \"CH3\")\n GCPair(\"[CX4;H2;!R]\", \"CH2\")\n GCPair(\"[CX3;H0;!R]\", \"C=\")\n GCPair(\"[OX1;H0;!R]\", \"O=\")\n GCPair(\"[CX3;H0;!R](=[OX1;H0;!R])\", \"C=O=\")\n\njulia> groups = find_missing_groups_from_smiles(\"CCCC(=O)CCC\"; reduced=true)\n3-element Vector{GCPair}:\n GCPair(\"[CX4;H3;!R]\", \"CH3\")\n GCPair(\"[CX4;H2;!R]\", \"CH2\")\n GCPair(\"[CX3;H0;!R](=[OX1;H0;!R])\", \"C=O=\")","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"As we can see, GCIdentifier proposes all the groups that one requires to represent this ketone. However, one aspect of this fragmentation that users may care about is that the methylene (CH_2) groups bonded to the ketone group versus those bonded to the methyl group could technically be treated different, due to the difference in environment within which they exist. This distinction can be made by adding the environment=true optional argument:","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"julia> groups = find_missing_groups_from_smiles(\"CCCC(=O)CCC\"; reduced=true, environment=true)\n6-element Vector{GCPair}:\n GCPair(\"[CX4;H3;!R;$([CX4;H3;!R]([CX4;H2;!R]))]\", \"CH3(CH2)\")\n GCPair(\"[CX4;H2;!R;$([CX4;H2;!R]([CX4;H3;!R])([CX4;H2;!R]))]\", \"CH2(CH3CH2)\")\n GCPair(\"[CX4;H2;!R;$([CX4;H2;!R]([CX4;H2;!R])([CX3;H0;!R]))]\", \"CH2(CH2C=)\")\n GCPair(\"[CX3;H0;!R;$([CX3;H0;!R]([CX4;H2;!R])(=[OX1;H0;!R])([CX4;H2;!R]))](=[OX1;H0;!R;$([OX1;H0;!R](=[CX3;H0;!R]))])\", \"C=(CH2O=CH2)O=(C=)\")\n GCPair(\"[CX4;H2;!R;$([CX4;H2;!R]([CX3;H0;!R])([CX4;H2;!R]))]\", \"CH2(C=CH2)\")\n GCPair(\"[CX4;H2;!R;$([CX4;H2;!R]([CX4;H2;!R])([CX4;H3;!R]))]\", \"CH2(CH2CH3)\")","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"As we can see in the above, GCIdentifier now proposes many more groups as we now care about the environment within which each group exists. ","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"One last flexible element of the find_missing_groups_from_smiles function is related to the size of the groups. In all of the above cases, the groups proposed only involve one or two heavy atoms. This is fine for most small molecules. However, for larger ones, such as adenylic acid, the groups proposed may not necessarily be the best representation:","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"julia> groups = find_missing_groups_from_smiles(\"C1=NC(=C2C(=N1)N(C=N2)C3C(C(C(O3)COP(=O)(O)O)O)O)N\"; reduced=true)\n12-element Vector{GCPair}:\n GCPair(\"[cX3;H1;R][nX2;H0;R]\", \"aCHaN\")\n GCPair(\"[cX3;H0;R][nX2;H0;R]\", \"aCaN\")\n GCPair(\"[cX3;H0;R][NX3;H2;!R]\", \"aCNH2\")\n GCPair(\"[cX3;H0;R][nX3;H0;R]\", \"aCaN\")\n GCPair(\"[cX3;H1;R][nX3;H0;R]\", \"aCHaN\")\n GCPair(\"[CX4;H1;R][nX3;H0;R]\", \"cCHaN\")\n GCPair(\"[CX4;H1;R][OX2;H0;R]\", \"cCHcO\")\n GCPair(\"[CX4;H1;R][OX2;H1;!R]\", \"cCHOH\")\n GCPair(\"[CX4;H1;R][CX4;H2;!R]\", \"cCHCH2\")\n GCPair(\"[OX2;H0;!R]([PX4;H0;!R])\", \"OP\")\n GCPair(\"[OX1;H0;!R]\", \"O=\")\n GCPair(\"[OX2;H1;!R]\", \"OH\")","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"Most groups here are quite reasonable, with the exception of the \"O=\" and \"OH\" groups as those will be bonded directly to the phosphorous atom, which we would expect results in very different \"O=\" and \"OH\" groups than you'd find on, for example, alcohols. While we could again use the environment capability of GCIdentifier to simply specify the environment in which these groups exist, this will result in far more groups being proposed. Ideally, we would like to combine the phosphate group into one. This can be done by specifying a larger max_group_size in the optional arguments:","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"julia> groups = find_missing_groups_from_smiles(\"C1=NC(=C2C(=N1)N(C=N2)C3C(C(C(O3)COP(=O)(O)O)O)O)N\"; reduced=true, max_group_size=5)\n10-element Vector{GCPair}:\n GCPair(\"[cX3;H1;R][nX2;H0;R]\", \"aCHaN\")\n GCPair(\"[cX3;H0;R][nX2;H0;R]\", \"aCaN\")\n GCPair(\"[cX3;H0;R][NX3;H2;!R]\", \"aCNH2\")\n GCPair(\"[cX3;H0;R][nX3;H0;R]\", \"aCaN\")\n GCPair(\"[cX3;H1;R][nX3;H0;R]\", \"aCHaN\")\n GCPair(\"[CX4;H1;R][nX3;H0;R]\", \"cCHaN\")\n GCPair(\"[CX4;H1;R][OX2;H0;R]\", \"cCHcO\")\n GCPair(\"[CX4;H1;R][OX2;H1;!R]\", \"cCHOH\")\n GCPair(\"[CX4;H1;R][CX4;H2;!R]\", \"cCHCH2\")\n GCPair(\"[PX4;H0;!R]([OX2;H0;!R])(=[OX1;H0;!R])([OX2;H1;!R])([OX2;H1;!R])\", \"POO=OHOH\")","category":"page"},{"location":"missing_groups/","page":"Finding Missing Groups","title":"Finding Missing Groups","text":"This is now a very reasonable representation of adenylic acid.","category":"page"},{"location":"custom_groups/#Defining-Custom-Groups","page":"Custom Groups","title":"Defining Custom Groups","text":"","category":"section"},{"location":"custom_groups/","page":"Custom Groups","title":"Custom Groups","text":"Within GCIdentifier, we support the following group-contribution methods:","category":"page"},{"location":"custom_groups/","page":"Custom Groups","title":"Custom Groups","text":"Joback's Method\nOriginal UNIFAC\n(Dortmund) UNIFAC\ngcPC-SAFT\ngcPPC-SAFT\nSAFT-gamma Mie","category":"page"},{"location":"custom_groups/","page":"Custom Groups","title":"Custom Groups","text":"There are many more available that we have yet to implement. If you wish do so yourself, then all that needs to be done is define a vector of GCPairs. GCPair is a struct contain the group SMARTS and name:","category":"page"},{"location":"custom_groups/","page":"Custom Groups","title":"Custom Groups","text":"julia> group = GCPair(\"[CX4H3]\",\"CH3\")\n\njulia> group.name\n\"CH3\"\n\njulia> group.smarts\n\"[CX4H3]\"","category":"page"},{"location":"custom_groups/","page":"Custom Groups","title":"Custom Groups","text":"While the group name is entirely arbitrary, one must be very careful when defining the SMARTS as this is the information used by GCIdentifier (and MolecularGraph) to identify the groups. To learn more about SMARTS, one can consult:","category":"page"},{"location":"custom_groups/","page":"Custom Groups","title":"Custom Groups","text":"Guide to understanding the SMARTS nomenclature\nTool to visualise SMARTS","category":"page"},{"location":"custom_groups/","page":"Custom Groups","title":"Custom Groups","text":"Once the user is certain of their SMARTS representation and made the vector of GCPairs, then one can simply feed in this vector (GroupList) into get_groups_from_smiles:","category":"page"},{"location":"custom_groups/","page":"Custom Groups","title":"Custom Groups","text":"julia> GroupList = [GCPair(\"[CX4H3]\",\"CH3\"),GCPair(\"[CX4H2]\",\"CH2\")]\n\njulia> get_groups_from_smiles(\"CCCC\", GroupList)\n(\"CCCC\", [\"CH3\" => 2, \"CH2\" => 2])","category":"page"},{"location":"custom_groups/","page":"Custom Groups","title":"Custom Groups","text":"If you've defined your own GroupList for an existing (or new) group-contribution method, feel free to open a pull request!","category":"page"},{"location":"#GCIdentifier.jl","page":"Home","title":"GCIdentifier.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to GCIdentifier! This module provides utilities needed to fragment a given molecular SMILES (or name) based on the groups provided in existing group-contribution methods (such as UNIFAC, Joback's method and SAFT-gamma Mie). Additional functionalities have been provided to automatically identify and propose new groups.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Group-contribution approaches are vital when it comes to computer-aided molecular design (CAMD) of, for example, novel refrigerants or in drug discovery, where their ability to accurately predict physical properties for new species aids in evaluating the performance of a hypothetical molecule. Here, the assignment of groups must be done thousands of times and, in some cases, for rather complex molecules. This is the primary motivator for the development of GCIdentifier.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation is laid out as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Group Assignment: Find out how to assign groups to a species within a group-contribution method.\nFinding Missing Groups: Find out how to identify missing groups for a given species.\nCustom Groups: Find out how to implement your own groups within GCIdentifier.\nAPI: A list of all available methods.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pierre J. Walker, California Institute of Technology\nAndrés Riedemann, University of Concepción","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GCIdentifier.jl is licensed under the MIT license.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GCIdentifier.jl is a registered package, it can be installed from the general registry by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add GCIdentifier","category":"page"}]
}
